<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gopher-Search and Rescue (G-SAR): Image Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gopher-Search and Rescue (G-SAR)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('image-processing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Image Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Applying a Filter to Your own Image</h2>
<p>To use the command-line Image Processing tool on your own images, you first need to obtain the source code for this project. Please view <a class="el" href="getting-started.html">Getting Started</a> on how to obtain a local copy of the source code to get started. <a class="el" href="getting-started.html">Getting Started</a> has a section titled 'Running an Image Filter on An Image (Command-Line Tool)' that describes how to compile and run the <a class="el" href="classImage.html" title="A class that holds content representing a PNG image. ">Image</a> Processing command-line tool.</p>
<p>Once you have obtained a local copy of the source code on your local machine you are ready to run your own image filtering.</p><ol type="1">
<li>Start run the Docker container using the instructions in the <b>Build Docker Environment</b> section in <a class="el" href="getting-started.html">Getting Started</a>.</li>
<li>Within your Docker container, navigate into the <code>project/ImageProcessing/</code> directory where the source code is located. This can be done by running the <code>cd project/ImageProcessing/</code> command.</li>
<li>Run the command <code>make clean &amp;&amp; make -j</code> to compile all of the source code required to run the image processor.</li>
<li>You are now ready to run the project using the following command: <code>./image_processor &lt;inputImage&gt; &lt;filter&gt; &lt;outputImage&gt;</code><ol type="a">
<li><code>&lt;inputImage&gt;</code> is a string that represents the relative path to the image that you want to apply a filter to (e.g. <code>"data/dog.png"</code>)</li>
<li><code>&lt;filter&gt;</code> is a string that represents the type of filter that you want to apply to your image. The filter options include:<ol type="i">
<li>greyscale - Applies a Greyscale filter to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>threshold - Applies a Threshold filter with a threshold of 0.50 to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>threshold-low - Applies a Threshold filter with a threshold of 0.25 to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>threshold-high - Applies a Threshold filter with a threshold of 0.75 to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>mean_blur - Applies a Mean Blur filter to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>gaussian - Applies a Gaussian Blur filter with a kernel size of 5 and a sigma value of 2 to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>double_threshold_filter - Applies a Double Threshold filter with a low threshold ratio of 0.10 and a high threshold ratio of 0.20 to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>hysteresis_filter - Applies a Hysteresis filter with a weak threshold of 25.0 and a strong threshold of 255.0 to the <code>&lt;inputImage&gt;</code> specified.</li>
<li>canny-edge-detect - Applies a Canny Edge Detection to the <code>&lt;inputImage&gt;</code> specified.</li>
</ol>
</li>
<li><code>&lt;outputImage&gt;</code> is a string that represents the relative path and file name of the image that will be generated by applying the specificed filter.</li>
</ol>
</li>
</ol>
<h2>Adding Your Own Filters</h2>
<p>Adding your own filters is relatively easy with this project.</p><ol type="1">
<li>Determine if the filter that you want to add fits into the category of a <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a>, or <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> based on the definitions above.<ol type="a">
<li>If so, create a new class for your filter that is derived from the correct categoral class (<a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a>, or <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a>).</li>
<li>If not, create a new categorical class for your new type of filter. This categorical class should be derived from the base <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> class.<ol type="i">
<li>This new categorical class will need to implement the pure virtual <code>Apply</code> method as defined in the <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> class. Use the <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, RelatedPixelsFilter, or <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> classes as templates for achieving this.</li>
</ol>
</li>
</ol>
</li>
<li>Once your have a categorical class that is derived from <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> that is appropriate for your new filter, create a new derived class from the correct categorical class for your brand new filter. Your new class will need to implement the pure virtual <code>ApplyAtPixel</code> method as defined in your categorical class. This method describes what the image filter does to each pixel in the image to apply the filter. Use the <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, RelatedPixelsFilter, or <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> classes as templates for achieving this.</li>
<li>Within <code>ImageProcessor.h</code> include the header file for your newly defined filter class and add the filter to the map of strings and filters within the <a class="el" href="classImageProcessor.html" title="A class that applies any filter. ">ImageProcessor</a> constructor. Use the already defined filters as a template.</li>
<li>Re-compile the source code using <code>make</code> as described in the <b>Running an Image Filter on An Image</b> section above.</li>
<li>Start applying your new filter to images!</li>
</ol>
<h2>Image Processor Design Structure</h2>
<p>All of the classes for this image processor iteration were created with the goal of designing code that is extensible, flexible and non-repetitive. Polymorphism, encapsulation and inheritance were used to achieve those goals. The filter class was implemented to serve as the base for all derived filter classes. Categorial filter classes, such as <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a>, were created to categorize filters based on how they apply a filter to an image. This section aims to give a detailed description of the design implemented.</p>
<p>Our design follows a facade design pattern, the complexity of the system is hidden and the <a class="el" href="classImageProcessor.html" title="A class that applies any filter. ">ImageProcessor</a> behaves as the interface for a user to interact with. The Image Processor contains the possible filters that can be applied to an image, such as <code>greyscale</code> and <code>canny-edge-detect</code>, and has a dependency to <a class="el" href="classImage.html" title="A class that holds content representing a PNG image. ">Image</a>, which means that an <a class="el" href="classImage.html" title="A class that holds content representing a PNG image. ">Image</a> is not held by the <a class="el" href="classImageProcessor.html" title="A class that applies any filter. ">ImageProcessor</a> but rather the <a class="el" href="classImageProcessor.html" title="A class that applies any filter. ">ImageProcessor</a> interacts with the <a class="el" href="classImage.html" title="A class that holds content representing a PNG image. ">Image</a> class through the <code>ApplyFiler(...)</code> method based on any <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> type passed as an input parameter. For this iteration, we assumed that the <code>sobel</code> and <code>non-max</code> filters were only used if implementing the canny edge detection, therefore the Image Processor cannot directly implement these two filters. Moreover, it was assumed that any image passed to the Image Processor as input existed.</p>
<div class="image">
<img src="../pages/images_uml/ImageClass.png" alt="Img class uml diagram" width="100%"/>
</div>
<p>Specifically, the design chosen to represent an image from the filesystem was as an instance of the <a class="el" href="classImage.html" title="A class that holds content representing a PNG image. ">Image</a> class, in which each <a class="el" href="classColor.html" title="A class that represents a pixel. Each component of the color is represented by a value between 0 and ...">Color</a> object represents a single pixel in the image, so an <a class="el" href="classImage.html" title="A class that holds content representing a PNG image. ">Image</a> object contains a unique pointer to an array of Colors.</p>
<div class="image">
<img src="../pages/images_uml/Color_Img.png" alt="Color and IMG uml diagram" width="100%"/>
</div>
<p><a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> Class serves as the abstract base class from which 3 main categories are derived: <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a> and <a class="el" href="classCanny.html" title="A filter that applies the greyscale, gaussian, sobel, non-max suppression, double threshold...">Canny</a>.</p>
<div class="image">
<img src="../pages/images_uml/Filter_UML.png" alt="Filter uml diagram" width="100%"/>
</div>
<p>The <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a> class is for filters that change a single image pixel without information about any other pixel in the image. Therefore, <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a> serves as the abstract class for greyscale, double threshold, and threshold image filters.</p>
<div class="image">
<img src="../pages/images_uml/SimpleFilter.png" alt="Simple Filter uml diagram" width="100%"/>
</div>
<p>Additionally, the <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a> class is an abstract class for any filter that calculates the new, filtered pixel color components based on other pixels in the image. Two filters that are derived from this class and that have been implemented are the <a class="el" href="classHysteresisFilter.html" title="A class that can be used to apply a Hysteresis Filter to an instance of the Image class...">HysteresisFilter</a> and the <a class="el" href="classNonMaxSupFilter.html" title="A Filter class that eliminates wide and fuzzy edges in an image. It only keeps the strongest pixel in...">NonMaxSupFilter</a> to apply a hysteresis and non-maximum suppression filter to an image, respectively. Moreover, <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> is a subcategory of the <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a> abstract class since a convolution filter needs to take into account surrounding pixels to determine the filtered value of a pixel and a kernel to be applied to those surrounding pixels.</p>
<div class="image">
<img src="../pages/images_uml/RelatedPixelFilter.png" alt="Related Pixel Filter uml diagram" width="100%"/>
</div>
<p>Each instance of the <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> class has a vector of kernels. <a class="el" href="classKernel.html" title="Class that represents the convolution kernel for a ConvolutionFilter. ">Kernel</a> is a class that stores the matrix representing the kernel values that need to be applied to the a pixel and its surrounding pixels to determine the new filtered pixel color values. This abstract <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> class serves as the basis for the <a class="el" href="classGaussianFilter.html" title="A ConvolutionFilter that computes a gaussian kernel given a kernel size and sigma. ">GaussianFilter</a> and the <a class="el" href="classSobelFilter.html" title="A filter that iterates two different kernels over an image to extract horizontal and vertical lines...">SobelFilter</a>, which called the parent constructor to initialize their respective kernels.</p>
<div class="image">
<img src="../pages/images_uml/ConvolutionFilter.png" alt="Convolution Filter uml diagram" width="100%"/>
</div>
<p>The last category of filters is the <a class="el" href="classCanny.html" title="A filter that applies the greyscale, gaussian, sobel, non-max suppression, double threshold...">Canny</a> filter, which implements the canny edge detection algorithm through the use of a composite pattern.</p>
<div class="image">
<img src="../pages/images_uml/Canny.png" alt="Canny Filter uml diagram" width="100%"/>
</div>
<p>As mentioned above, all of the classes for this image processor iteration were created with the goal of designing code that is extensible, flexible and non-repetitive, thereby allowing for all of our code to be close to modification and open to extension. Adding a new filter is a straightforward process. First, determine if the filter that you want to add fits into the category of a <a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a>, or <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a> based on the definitions above. If it follows one of those definitions, create a new class for your filter that is derived from the correct categorical class (<a class="el" href="classSimpleFilter.html" title="An abstract class that represents a filter that applies a change on an individual pixel exclusively b...">SimpleFilter</a>, <a class="el" href="classRelatedPixelFilter.html" title="Abstract class that defines the virtual methods for all classes derived from RelatedPixelFilter. ">RelatedPixelFilter</a>, or <a class="el" href="classConvolutionFilter.html" title="ConvolutionFilter is an abstract Filter class with a convolution kernel. In order to compute the valu...">ConvolutionFilter</a>). Your new <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> class will need to implement the <code>ApplyAtPixel(...)</code> method, which applies the given filter to a specific pixel (x,y). On the other hand, if it is a “new” categorical filterm create a class for your filter that inherits directly from <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> class. Note that this new categorical filter will need to implement the pure virtual <code>Apply(...)</code> method as defined in the <a class="el" href="classFilter.html" title="Abstract class that defines the virtual methods for all filter classes. ">Filter</a> class.</p>
<p>Note, that although the explanation above uses our implementation of filters, the <a class="el" href="classRescueSimulation.html" title="A facade to start, interact, and end a rescue simulation. ">RescueSimulation</a> uses the <code>opencv</code> library by creating an <a class="el" href="classObjectDetector.html" title="A class used to detect the orange Robot within a given image. ">ObjectDetector</a> that implements the canny and edge detect filter via <code>opencv</code> directly to check if the robot was found. The reason behind this design choice was primarily speed. Our implementation of canny edge detection took approximately 15 seconds, while the <code>opencv</code> library canny edge detection took less than 1 second. Moreover, we created an <a class="el" href="classObjectDetector.html" title="A class used to detect the orange Robot within a given image. ">ObjectDetector</a> class rather than an image processor because we also needed to determine which pixel in the image the robot was found at.</p>
<h2>Copyright</h2>
<p>&copy; 2021 Laura Arias Fernandez, Michael Weiner, and Malik Khadar All rights reserved. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
